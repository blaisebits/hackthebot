import pickle

from langchain_core.messages import AIMessage
from langgraph.constants import START
from langgraph.graph import StateGraph
from langgraph.prebuilt import ToolNode

from utils.Configuration import Configuration
from utils.HostUpdate import get_stub_host
from utils.LLMHelpers import llm_invoke_retry
from utils.LangChain_RoboPages import RoboPages
from utils.Prompts import get_exploit_suggestion_prompt_template
from utils.States import StingerState, Host, ExploitTask
from utils.Tasking import get_new_task

rb = RoboPages()
rb_tools = rb.get_tools()
llm = Configuration["llm"]
recon_tool_node = ToolNode(rb_tools)

def load_pickle(state: StingerState):
    if state["current_task"] == -1:
        # Load pickle from disk
        with open('data.pickle', 'rb') as file:
            state = pickle.load(file)
    else:
        # Pickle state table and save to disk
        with open('data.pickle', 'wb') as file:
            pickle.dump(state, file)

    return state

def exploit_agent(state: StingerState):
    task_str:str|None = None
    agent_messages = []
    context = []
    target:[Host] = []

    # Tasking workflow:
    #  Checking if working -> proceed to tool calling again
    #  Check if validated -> check for next task
    #  Check if new -> do preflightcheck and tool calls.
    if not state["tasks"][state["current_task"]]["agent"] == "Exploit":  # Not assigned to Exploit
        state["current_task"] = get_new_task("Exploit", state["tasks"])

    if state["tasks"][state["current_task"]]["agent"] == "Exploit":  # Task assigned to Exploit
        if state["tasks"][state["current_task"]]["status"] == "working":  # Task is working
            task_str = state["tasks"][state["current_task"]]["task"]
            target_ip = state["tasks"][state["current_task"]]["target_ip"]
            context.append(state["hosts"][target_ip])
            agent_messages.append(AIMessage(f"ExploitAgent: Reworking task {state["current_task"]}: \"{task_str}\"."))

        elif (state["tasks"][state["current_task"]]["status"] == "validated"
              or state["tasks"][state["current_task"]]["status"] == "new"):  # task is validated/new

            if state["tasks"][state["current_task"]]["status"] == "validated":
                state["current_task"] = get_new_task("Exploit", state["tasks"])
                if state["current_task"] == -1:  # No more tasks for this agent
                    return {
                        "messages": [AIMessage("ExploitAgent: No Tasks were marked for execution. Passing to Stinger.")]}

            task_str = state["tasks"][state["current_task"]]["task"]
            target_ip = state["tasks"][state["current_task"]]["target_ip"]
            state["tasks"][state["current_task"]]["status"] = "working"
            agent_messages.append(AIMessage(f"ExploitAgent: Starting new task {state["current_task"]}: \"{task_str}\"."))

            if not state["tasks"][state["current_task"]]["preflightcheck"]:  # No PFC yet
                if state["tasks"][state["current_task"]]["target_ip"] in state[
                    "hosts"].keys():  # Target IP has entry in host table
                    agent_messages.append(AIMessage(
                        f"ExploitAgent: Sending task {state["current_task"]}: \"{task_str}\" to validator for pre-flight check."))
                    return {
                        "messages": agent_messages,
                        "current_task": state["current_task"]
                    }
                else:
                    # Add blank entry to host table
                    target_host = get_stub_host(state["tasks"][state["current_task"]]["target_ip"])

                    state["hosts"][target_host["ip_address"]] = target_host
                    state["tasks"][state["current_task"]]["preflightcheck"] = True
                    task_str = state["tasks"][state["current_task"]]["task"]
            target.append(state["hosts"][target_ip])
            context.append(state["tasks"][state["current_task"]]["output"]) #any previous failed exploit attempts

        else:  # No tasks available, routing back to Stinger
            return {"messages": [AIMessage("ExploitAgent: No Tasks were marked for execution. Passing to Stinger.")]}

    ## Setting up LLM Call
    if task_str is not None:
        exploit_suggestion_prompt_template = get_exploit_suggestion_prompt_template()
        exploit_suggestion_prompt = exploit_suggestion_prompt_template.invoke(
            {
                "task": task_str,
                "target": target,
                "context": context
            }
        )
        llm_with_tools = llm.bind_tools(ExploitTask)
        # response = llm_with_tools.invoke(exploit_suggestion_prompt)
        response = llm_invoke_retry(llm_with_tools, exploit_suggestion_prompt)
        state["tasks"][state["current_task"]]["tool"].append(response.tool_calls[0]["name"])
        agent_messages.append(response)
        return {
            "messages": agent_messages,
            "tasks": state["tasks"],
            "current_task": state["current_task"],
            "hosts": state["hosts"]
        }
    else:
        # return no tasks response
        return {"messages": [AIMessage("ExploitAgent: No Tasks were marked for execution. Passing to Stinger.")]}






exploit_workflow = StateGraph(StingerState)

exploit_workflow.add_edge(START, "LoadPickle")
exploit_workflow.add_node("LoadPickle", load_pickle)

exploit_graph = exploit_workflow.compile()

# if __name__ == "__main__":