import pickle
from typing import List
from json import loads as json_loads

from langchain_core.messages import AIMessage, ToolMessage
from langchain_core.prompt_values import PromptValue
from langchain_core.prompts import ChatPromptTemplate
from langchain_core.runnables import Runnable
from langchain_core.runnables.utils import Output
from langgraph.constants import START
from langgraph.graph import StateGraph
from langgraph.prebuilt import ToolNode
from langgraph.types import Command

from utils.Configuration import Configuration
from utils.ContextHelpers import build_exploit_task_context
from utils.HostUpdate import get_stub_host
from utils.LLMHelpers import llm_invoke_retry
from utils.OutputFormatters import TaskAnswer, ExploitSuggestions, ExploitStepFormatter, SpecialAgentCaller, \
    ExploitStepUpdates, ExploitTaskUpdates
from utils.Prompts import get_exploit_suggestion_prompt_template, get_exploit_planner_prompt_template, \
    get_exploit_step_prompt_template, get_exploit_step_status_template
from utils.SpecialAgents import SpecialAgents
from utils.States import StingerState, ExploitTask, Task, ExploitStep, InitialAccessExploit, ExploitCode
from utils.Tasking import get_new_task, expand_exploit_suggestion, create_exploit_step, get_current_exploit_task, \
     get_current_exploit_step, repair_scratchpad
from utils.Tooling import RoboPagesTools

MAX_STEP_RETRIES:int = 5

rb = RoboPagesTools
rb_tools = rb.filter_tools_by_agent(["ExploitAgent","AllAgents"])
sp = SpecialAgents

llm = Configuration["llm"]

last_tool_called:str = ""

exploit_step_tool_node = ToolNode(rb_tools)

# Checks for a blank state table and loads from disk
# If non-blank state table, save state stable to disk as a pickle
def load_pickle(state: StingerState):
    if "current_task" in state:
        if state["current_task"] > 0:
            # assume task work as be done
            # Pickle state table to disk
            with open('data.pickle', 'wb') as file:
                # noinspection PyTypeChecker
                pickle.dump(state, file)
                return state

    # assume no work has been done or blank state table
    # Load pickle from disk
    with open('data.pickle', 'rb') as file:
        state = pickle.load(file)
    return state

def exploit_agent(state: StingerState):
    task_str:str|None = None
    agent_messages = []

    # Tasking workflow:
    #  Check if validated -> check for next task
    #  Check if new -> do preflightcheck and tool calls.
    if not state["tasks"][state["current_task"]]["agent"] == "Exploit":  # Not assigned to Exploit
        state["current_task"] = get_new_task("Exploit", state["tasks"])

    current_task:Task = state["tasks"][state["current_task"]]

    if current_task["agent"] == "Exploit":  # Task assigned to Exploit
        if current_task["status"] == "working":  # Task is working
            # Check for ExploitTask
            exploit_tasks:[ExploitTask] = current_task["output"]
            # Check if ExploitTask was marked "exploitable"
            for ex_task in exploit_tasks:
                if ex_task.get("status") is not None and ex_task["status"] == "exploitable":
                    # noinspection PyTypeChecker
                    target_ip:str = ex_task["target_ip"]
                    # noinspection PyTypeChecker
                    iae:InitialAccessExploit = ex_task["initial_access_exploit"]
                    state["hosts"][target_ip]["initial_access_exploit"].append(iae)
                    # noinspection PyTypedDict
                    state["tasks"][state["current_task"]]["status"] = "validated"

                    return {
                        "hosts": state["hosts"],
                        "tasks": state["tasks"],
                        "messages": [AIMessage(f"ExploitAgent: Validating task {state["current_task"]} with initial access exploit for {target_ip}."),
                                     AIMessage("Passing to Stinger")]
                    }

            task_str = state["tasks"][state["current_task"]]["task"]
            agent_messages.append(AIMessage(f"ExploitAgent: Reworking task {state["current_task"]}: \"{task_str}\"."))

        elif (current_task["status"] == "validated"
              or current_task["status"] == "new"):  # task is validated/new

            if current_task["status"] == "validated":
                state["current_task"] = get_new_task("Exploit", state["tasks"])
                if state["current_task"] == -1:  # No more tasks for this agent
                    return {
                        "messages": [AIMessage("ExploitAgent: No Tasks were marked for execution. Passing to Stinger.")]}

            task_str = current_task["task"]
            # noinspection PyTypedDict
            state["tasks"][state["current_task"]]["status"] = "working"
            agent_messages.append(AIMessage(f"ExploitAgent: Starting new task {state["current_task"]}: \"{task_str}\"."))

            if not state["tasks"][state["current_task"]]["preflightcheck"]:  # No PFC yet
                if state["tasks"][state["current_task"]]["target_ip"] in state[
                    "hosts"].keys():  # Target IP has entry in host table
                    agent_messages.append(AIMessage(
                        f"ExploitAgent: Sending task {state["current_task"]}: \"{task_str}\" to validator for pre-flight check."))
                    return {
                        "messages": agent_messages,
                        "current_task": state["current_task"]
                    }
                else:
                    # Add blank entry to host table
                    target_host = get_stub_host(state["tasks"][state["current_task"]]["target_ip"])

                    state["hosts"][target_host["ip_address"]] = target_host
                    state["tasks"][state["current_task"]]["preflightcheck"] = True
                    task_str = state["tasks"][state["current_task"]]["task"]

        else:  # No tasks available, routing back to Stinger
            return {"messages": [AIMessage("ExploitAgent: No Tasks were marked for execution. Passing to Stinger.")]}

    ## Setting up LLM Call
    if task_str is not None:
        # helper variables
        task_id = state["current_task"]
        target_ip = state["tasks"][ task_id ]["target_ip"]

        #prompt variables
        task_str = state["tasks"][ task_id ]["task"]
        target = state["hosts"][ target_ip ]
        context = state["tasks"][ task_id ]["output"]

        exploit_suggestion_prompt_template = get_exploit_suggestion_prompt_template()
        exploit_suggestion_prompt = exploit_suggestion_prompt_template.invoke(
            {
                "task": task_str,
                "target": target,
                "context": context
            }
        )
        llm_with_tools = llm.bind_tools([ExploitSuggestions])
        response = llm_invoke_retry(llm_with_tools, exploit_suggestion_prompt)
        agent_messages.append(response)
        tasks = response.tool_calls[0]["args"]["tasks"]

        # Create ExploitTask, nest in output for parent Task
        for task in tasks:
            exploit_task = expand_exploit_suggestion(target_ip, task)
            state["tasks"][ state["current_task"] ]["output"].append(exploit_task)
        return {
            "messages": agent_messages,
            "tasks": state["tasks"],
            "current_task": state["current_task"],
            "hosts": state["hosts"]
        }
    else:
        # return no tasks response
        return {"messages": [AIMessage("ExploitAgent: No Tasks were marked for execution. Passing to Stinger.")]}


def validator(state: StingerState):
    current_task_index:int = state["current_task"]
    state["tasks"][current_task_index]["preflightcheck"] = True

    ex_task_index:int = get_current_exploit_task(state)
    ex_task:ExploitTask = state["tasks"][ state["current_task"] ]["output"][ex_task_index]
    ex_task_iae:InitialAccessExploit = ex_task["initial_access_exploit"]

    # Check ExploitTask Initial Access Exploit
    if ex_task_iae is None:
        return {
            "messages": [AIMessage("ExploitValidator: No Initial Access Payload available. Passing to ExploitAgent.")]
        }
    else:
        # noinspection PyTypedDict
        state["tasks"][state["current_task"]]["status"] = "validated"
        question = state["tasks"][state["current_task"]]["task"]
        answer = f"Initial Access Exploit for {ex_task.get("target_ip")} as {"code" if isinstance(ex_task["initial_access_exploit"],ExploitCode) else "tool"}."
        reason = f"Task {current_task_index} marked as \"{ex_task.get("status")}\"."
        # noinspection PyTypedDict
        state["tasks"][state["current_task"]]["verdict"] = TaskAnswer(
            question=question,
            answer=answer,
            reason=reason
        )
        return {
            "messages": [AIMessage(f"ExploitValidator: Task {state["current_task"]} validated.\n"
                                   f"Question: {question}\n"
                                   f"Answer: {answer}\n")],
            "tasks": state["tasks"]
        }


def handoff(state: StingerState):
    """Hand off back to stinger"""
    return Command(
        goto="StingerAgent",
        update=state,
        graph=Command.PARENT
    )

def exploit_router(state: StingerState):
    last_message = state["messages"][-1]
    current_task = state["tasks"][state["current_task"]]
    preflightcheck = current_task["preflightcheck"]

    if last_message.tool_calls:
        if last_message.tool_calls[0]["name"] == "ExploitSuggestions":
            return "ExploitStepPlanner"
    if not preflightcheck: return "ExploitValidator"

    return "ExploitHandoff"

def exploit_step_planner(state: StingerState):
    """
    Task the current exploit task and plan the ExploitSteps needed
    """
    # Extract helper variables
    current_task = state["current_task"]
    target_ip = state["tasks"][ current_task ]["target_ip"]
    target = state["hosts"][target_ip]

    # Extract the current working ExploitTask from Task.output
    exploit_task = None
    exploit_task_index = None
    for index, element in enumerate(state["tasks"][current_task]["output"]):
        if element["status"] == "new":
            exploit_task = element
            exploit_task_index = index
            break

    # Bail out back to Exploit Suggestion
    # if exploit_task == None

    # Call LLM to supply ExploitSteps to complete the task
    exploit_planner_prompt_template = get_exploit_planner_prompt_template()
    exploit_planner_prompt = exploit_planner_prompt_template.invoke(
        {
            "exploit_task": exploit_task["task"],
            "target": target,
            "context": ""
        }
    )

    llm_with_tools = llm.bind_tools([ExploitStepFormatter])
    response = llm_invoke_retry(llm_with_tools, exploit_planner_prompt)

    #Update state table
    steps = response.tool_calls[0]["args"]["steps"]
    exploit_steps: [ExploitStepFormatter] = list(map(lambda x: create_exploit_step(x), steps))
    exploit_steps.append(create_exploit_step("Create initial access exploit for the target"))
    exploit_steps.append(create_exploit_step("Verify the initial access exploit by sending the `pwd` command"))

    state["tasks"][ current_task ]["output"][exploit_task_index]["steps"] = exploit_steps
    state["tasks"][ current_task ]["output"][exploit_task_index]["status"] = "working"

    return {
        "tasks": state["tasks"]
    }

def exploit_step_processor(state: StingerState):
    """
    Finds the ExploitTask current_step and send the step with data
    to the LLM to find a tool.
    """
    exploit_task_index:int = get_current_exploit_task(state)
    exploit_task:ExploitTask = state["tasks"][ state["current_task"] ]["output"][ exploit_task_index ]

    exploit_steps:List[ExploitStep] = exploit_task["steps"]
    current_step_index:int = get_current_exploit_step(state)

    step_task:str = exploit_steps[current_step_index]["step_task"]
    exploit_step_prompt_template = get_exploit_step_prompt_template()

    context = build_exploit_task_context(state)

    exploit_step_prompt = exploit_step_prompt_template.invoke(
        {
            "agents": sp.agent_prompt_data(),
            "step": step_task,
            "context": context
        }
    )

    llm_with_tools = llm.bind_tools(rb_tools+[SpecialAgentCaller])
    response: AIMessage = llm_invoke_retry(llm_with_tools, exploit_step_prompt)

    scratchpad:str = f"{ response.content }\n{ response.tool_calls }"
    state["tasks"][state["current_task"]]["output"][exploit_task_index]["steps"][current_step_index]["status"] = "working"
    state["tasks"][state["current_task"]]["output"][exploit_task_index]["steps"][current_step_index]["scratchpad"] = scratchpad


    return {
        "messages": response,
        "tasks": state["tasks"]
    }

def exploit_step_tool_router(state:StingerState):
    # Check the last message tool call for the name of the tool
    if state["messages"][-1].tool_calls[0]["name"] == 'SpecialAgentCaller':
        return "ExploitSpecialAgentNode"
    else:
        return "ExploitStepToolNode"

async def exploit_step_special_agent_node(state: StingerState):
    agent_to_call = state["messages"][-1].tool_calls[0]["args"]["name"]
    response = await sp.agents[agent_to_call].graph.ainvoke(state)
    return response

def exploit_step_update(state: StingerState):
    ai_messages:List[AIMessage] = []
    exploit_task_index:int = get_current_exploit_task(state)
    exploit_step_index:int = get_current_exploit_step(state)

    last_message:ToolMessage|AIMessage = state["messages"][-1]
    if last_message.type == 'tool':
        ai_messages.append(AIMessage("ExploitStepUpdate: Appending Tool call output"))
        tool_output:str = last_message.content if isinstance(last_message, AIMessage) else json_loads(last_message.content)["content"]
        # noinspection PyTypeChecker,PyUnresolvedReferences
        state["tasks"][state["current_task"]]["output"][exploit_task_index]["steps"][exploit_step_index]["scratchpad"] += f"\n{tool_output}"
        return {
            "messages": ai_messages,
            "tasks":state["tasks"]
        }
    else:
        return {
            "messages": AIMessage("ExploitStepUpdate: No Tool Call output found."),
            "tasks": state["tasks"]
        }

def exploit_step_revizor(state: StingerState):
    """
    Check if the exploitstep executed correctly
    If step tool array length is >= MAX_RETRIES then mark as failed and bail
    If validated, setup to move on to next step
    if failed, update step with revision
    """

    ai_messages:List[AIMessage] = []
    current_task:int = state["current_task"]
    task:Task = state["tasks"][current_task]

    exploit_task_index:int = get_current_exploit_task(state)
    exploit_task:ExploitTask = task["output"][exploit_task_index]

    exploit_steps:list[ExploitStep] = exploit_task["steps"]

    current_step:int = get_current_exploit_step(state)
    # noinspection PyTypeChecker
    exploit_step:ExploitStepFormatter = exploit_task["steps"][ current_step]
    ai_messages.append(AIMessage(f"ExploitStepRevizor: Checking status of Exploit Task {exploit_task_index}, step {current_step}."))

    exploit_step_status_template:ChatPromptTemplate = get_exploit_step_status_template()
    exploit_step_status_prompt:PromptValue = exploit_step_status_template.invoke(
        {
            "step": exploit_step,
            "exploit_task": exploit_task
        }
    )

    llm_with_tools:Runnable = llm.bind_tools([ExploitStepUpdates, ExploitTaskUpdates])

    response:Output =  llm_invoke_retry(llm_with_tools,exploit_step_status_prompt)
    output:AIMessage = response
    ai_messages.append(response)


    # Update the exploit task steps with the new version from the LLM
    # annoying_debug(response)

    if output.tool_calls[0]["name"] == 'ExploitStepUpdates':
        output_steps:[ExploitStep] = response.tool_calls[0]["args"]["updates"]

        original_ids:[str] = [x["id"] for x in exploit_steps]
        output_ids:[str] = [x["id"] for x in output_steps]

        # Check that all steps are accounted for and present
        ai_messages.append(AIMessage("ExploitStepRevizor: Repopulated Exploit Steps scratchpads"))
        if original_ids == output_ids: # ordered 1-1 match
            for i,step in enumerate(exploit_steps):
                output_steps[i]["scratchpad"] = step["scratchpad"]
        else:
            repair_scratchpad(output_steps, exploit_steps)

        state["tasks"][current_task]["output"][exploit_task_index]["steps"] = output_steps

    elif output.tool_calls[0]["name"] == 'ExploitTaskUpdates':
        new_initial_access_exploit:str = response.tool_calls[0]["args"]["initial_access_exploit"]
        new_status:str = response.tool_calls[0]["args"]["status"]

        state["tasks"][current_task]["output"][exploit_task_index]["status"] = new_status
        state["tasks"][current_task]["output"][exploit_task_index]["initial_access_exploit"] = new_initial_access_exploit
        # Manually validate last step
        state["tasks"][current_task]["output"][exploit_task_index]["steps"][-1]["status"] = "validated"
    elif output.tool_calls[0]["name"] == 'ExploitBailOut':
        state["tasks"][current_task]["output"][exploit_task_index]["status"] = "failed"
        ai_messages.append(AIMessage(f"ExploitStepRevizor: Bailing out on exploit task {exploit_task_index}"))
    return {
        "messages": ai_messages,
        "tasks": state["tasks"]
    }


def exploit_step_router(state:StingerState):
    current_working_exploit_task_index:int = get_current_exploit_task(state)

    if current_working_exploit_task_index is None:
        return "ExploitAgent"
    else:
        return "ExploitStepProcessor"

# noinspection PyTypeChecker
exploit_workflow = StateGraph(StingerState)

exploit_workflow.add_edge(START, "LoadPickle")
# noinspection PyTypeChecker
exploit_workflow.add_node("LoadPickle", load_pickle)

exploit_workflow.add_edge("LoadPickle", "ExploitAgent")
# noinspection PyTypeChecker
exploit_workflow.add_node("ExploitAgent", exploit_agent)

exploit_workflow.add_conditional_edges("ExploitAgent", exploit_router, ["ExploitHandoff", "ExploitValidator", "ExploitStepPlanner"])

# noinspection PyTypeChecker
exploit_workflow.add_node("ExploitHandoff", handoff)
# noinspection PyTypeChecker
exploit_workflow.add_node("ExploitValidator", validator)
exploit_workflow.add_edge("ExploitValidator", "ExploitAgent")

###################################
# Nodes for executing exploit steps
###################################
# noinspection PyTypeChecker
exploit_workflow.add_node("ExploitStepPlanner", exploit_step_planner)

exploit_workflow.add_edge("ExploitStepPlanner", "ExploitStepProcessor")
# noinspection PyTypeChecker
exploit_workflow.add_node("ExploitStepProcessor", exploit_step_processor)

exploit_workflow.add_conditional_edges("ExploitStepProcessor", exploit_step_tool_router, ["ExploitStepToolNode", "ExploitSpecialAgentNode"])
exploit_workflow.add_node("ExploitStepToolNode", exploit_step_tool_node)
# noinspection PyTypeChecker
exploit_workflow.add_node("ExploitSpecialAgentNode", exploit_step_special_agent_node)

exploit_workflow.add_edge("ExploitStepToolNode", "ExploitStepUpdate")
exploit_workflow.add_edge("ExploitSpecialAgentNode", "ExploitStepUpdate")
# noinspection PyTypeChecker
exploit_workflow.add_node("ExploitStepUpdate", exploit_step_update)

exploit_workflow.add_edge("ExploitStepUpdate","ExploitStepRevizor")
# noinspection PyTypeChecker
exploit_workflow.add_node("ExploitStepRevizor", exploit_step_revizor)

exploit_workflow.add_conditional_edges("ExploitStepRevizor", exploit_step_router, ["ExploitStepProcessor","ExploitAgent"])


exploit_graph = exploit_workflow.compile()

if __name__ == "__main__":
    # print(os.getcwd())
    # noinspection PyTypeChecker
    exploit_graph.invoke({})