import pickle
from copy import deepcopy
from typing import List
from json import loads as json_loads

from langchain_core.messages import AIMessage, ToolMessage
from langchain_core.prompt_values import PromptValue
from langchain_core.prompts import ChatPromptTemplate
from langchain_core.runnables import Runnable
from langchain_core.runnables.utils import Output
from langgraph.constants import START
from langgraph.graph import StateGraph
from langgraph.prebuilt import ToolNode
from langgraph.types import Command

from utils.Configuration import Configuration
from utils.ContextHelpers import build_exploit_task_context
from utils.HostUpdate import get_stub_host
from utils.LLMHelpers import llm_invoke_retry
from utils.OutputFormatters import TaskAnswer, ExploitSuggestions, ExploitStepFormatter, SpecialAgentCaller, \
    ExploitStepUpdates, ExploitTaskUpdates
from utils.Prompts import get_exploit_suggestion_prompt_template, get_exploit_planner_prompt_template, \
    get_exploit_step_prompt_template, get_exploit_step_status_template
from utils.SpecialAgents import SpecialAgents
from utils.States import StingerState, ExploitTask, Task, ExploitStep, InitialAccessExploit, ExploitCode, Host
from utils.Tasking import get_new_task, expand_exploit_suggestion, create_exploit_step, get_current_exploit_task, \
     get_current_exploit_step, repair_scratchpad
from utils.Tooling import RoboPagesTools

MAX_STEP_RETRIES:int = 5

rb = RoboPagesTools
rb_tools = rb.filter_tools_by_agent(["ExploitAgent","AllAgents"])
sp = SpecialAgents

llm = Configuration["llm"]

last_tool_called:str = ""

exploit_step_tool_node = ToolNode(rb_tools)

# Checks for a blank state table and loads from disk
# If non-blank state table, save state stable to disk as a pickle
def load_pickle(state: StingerState):
    if "current_task" in state:
        if state["current_task"] > 0:
            # assume task work as be done
            # Pickle state table to disk
            with open('data.pickle', 'wb') as file:
                # noinspection PyTypeChecker
                pickle.dump(state, file)
                return {}

    # assume no work has been done or blank state table
    # Load pickle from disk
    with open('data.pickle', 'rb') as file:
        state = pickle.load(file)
    return state

def exploit_agent(state: StingerState):
    task_str:str|None = None
    agent_messages = []

    input_current_task: int = state["current_task"]
    input_tasks:list[Task] = state["tasks"]
    input_task: Task = input_tasks[input_current_task]
    # input_hosts:dict[str, Host] = state["hosts"]

    output_hosts:dict[str, Host] = {}
    output_task:list[Task]|Task|None = deepcopy(input_task)

    if input_task["agent"] != "Exploit" or (input_task["status"] not in ["working", "new"]):
        return {"messages": [AIMessage("ExploitAgent: Task not assigned to me. Passing to Stinger.")]}

    if input_task["status"] == "working":
        # Check for ExploitTask
        exploit_tasks:[ExploitTask] = input_task["output"]
        # Check if ExploitTask was marked "exploitable"
        for ex_task in exploit_tasks:
            # Does an exploit task exist that is exploitable
            if ex_task.get("status") is not None and ex_task["status"] == "exploitable":
                # noinspection PyTypeChecker
                target_ip:str = ex_task["target_ip"]
                # noinspection PyTypeChecker
                iae:InitialAccessExploit = ex_task["initial_access_exploit"]
                output_hosts = { target_ip: deepcopy(state["hosts"][target_ip]) }
                output_hosts[target_ip]["initial_access_exploit"].append(iae)
                # noinspection PyTypedDict
                output_tasks = deepcopy(input_task)
                output_tasks["status"] = "validated"

                return {
                    "hosts": output_hosts,
                    "tasks": output_tasks,
                    "messages": [AIMessage(f"ExploitAgent: Validating task {state["current_task"]} with initial access exploit for {target_ip}."),
                                 AIMessage("Passing to Stinger")]
                }

        task_str = input_task["task"]
        agent_messages.append(AIMessage(f"ExploitAgent: Reworking task {state["current_task"]}: \"{task_str}\"."))
        # noinspection PyTypedDict
        output_task["status"] = "working"

        if not input_task["preflightcheck"]:  # No PFC yet
            if input_task["target_ip"] in state["hosts"].keys():  # Target IP has entry in host table
                agent_messages.append(AIMessage(
                    f"ExploitAgent: Sending task {input_current_task}: \"{task_str}\" to validator for pre-flight check."))
                return { "messages": agent_messages }
            else:
                # Add blank entry to host table
                # Not Entry means no IAE, so skip preflight
                target_host = get_stub_host(input_task["target_ip"])

                output_hosts = { target_host["ip_address"]: target_host }
                output_task["preflightcheck"] = True

    elif input_task["status"] == "new":
        task_str = input_task["task"]
        output_task["status"] = "working"
        agent_messages.append(AIMessage(f"ExploitAgent: Starting new task {input_current_task}: \"{task_str}\"."))

    else:  # No tasks available, routing back to Stinger
        return {"messages": [AIMessage("ExploitAgent: No Tasks were marked for execution. Passing to Stinger.")]}

    ## Setting up LLM Call
    if task_str is not None:
        # helper variables
        target_ip = input_task["target_ip"]

        #prompt variables
        target = state["hosts"][ target_ip ]
        context = state["tasks"][ input_current_task ]["output"]

        exploit_suggestion_prompt_template = get_exploit_suggestion_prompt_template()
        exploit_suggestion_prompt = exploit_suggestion_prompt_template.invoke(
            {
                "task": task_str,
                "target": target,
                "context": context
            }
        )
        llm_with_tools = llm.bind_tools([ExploitSuggestions])
        response = llm_invoke_retry(llm_with_tools, exploit_suggestion_prompt)
        agent_messages.append(response)
        exploit_tasks = response.tool_calls[0]["args"]["tasks"]

        # Create ExploitTask, nest in output for parent Task
        for task in exploit_tasks:
            exploit_task = expand_exploit_suggestion(target_ip, task)
            output_task["output"].append(exploit_task)
        return {
            "messages": agent_messages,
            "tasks": output_task,
            "hosts": output_hosts
        }
    else:
        # return no tasks response
        return {"messages": [AIMessage("ExploitAgent: No Tasks were marked for execution. Passing to Stinger.")]}


def validator(state: StingerState):
    input_current_task_index:int = state["current_task"]
    input_task:Task = state["tasks"][input_current_task_index]

    output_task = deepcopy(input_task)
    output_task["preflightcheck"] = True

    ex_task_index:int = get_current_exploit_task(state)

    if ex_task_index is None:
        return {
            "messages": [AIMessage("ExploitValidator: No \"new\" or \"working\" ExploitTasks . Passing to ExploitAgent.")],
            "tasks": output_task
        }

    ex_task:ExploitTask = state["tasks"][ state["current_task"] ]["output"][ex_task_index]
    ex_task_iae:InitialAccessExploit = ex_task["initial_access_exploit"]


    if ex_task_iae is None:
        return {
            "messages": [AIMessage("ExploitValidator: No Initial Access Exploit available. Passing to ExploitAgent.")],
            "tasks": output_task
        }
    else:
        # noinspection PyTypedDict
        output_task["status"] = "validated"
        question = state["tasks"][state["current_task"]]["task"]
        answer = f"Initial Access Exploit for {ex_task.get("target_ip")} as {"code" if isinstance(ex_task["initial_access_exploit"],ExploitCode) else "tool"}."
        reason = f"Task {input_current_task_index} marked as \"{ex_task.get("status")}\"."

        # noinspection PyTypeChecker
        output_task["verdict"] = TaskAnswer(
            question=question,
            answer=answer,
            reason=reason
        )
        return {
            "messages": [AIMessage(f"ExploitValidator: Task {state["current_task"]} validated.\n"
                                   f"Question: {question}\n"
                                   f"Answer: {answer}\n")],
            "tasks": output_task
        }


def handoff(state: StingerState):
    """Hand off back to stinger"""
    return Command(
        goto="StingerAgent",
        update=state,
        graph=Command.PARENT
    )

def exploit_router(state: StingerState):
    last_message = state["messages"][-1]
    current_task = state["tasks"][state["current_task"]]
    preflightcheck = current_task["preflightcheck"]

    if last_message.tool_calls:
        if last_message.tool_calls[0]["name"] == "ExploitSuggestions":
            return "ExploitStepPlanner"
    if not preflightcheck: return "ExploitValidator"

    return "ExploitHandoff"

def exploit_step_planner(state: StingerState):
    """
    Task the current exploit task and plan the ExploitSteps needed
    """
    # Extract helper variables
    current_task = state["current_task"]
    output_task:Task|None = None
    target_ip = state["tasks"][ current_task ]["target_ip"]
    target = state["hosts"][target_ip]

    # Extract the current working ExploitTask from Task.output
    exploit_task = None
    exploit_task_index = None
    for index, element in enumerate(state["tasks"][current_task]["output"]):
        if element["status"] == "new":
            exploit_task = element
            exploit_task_index = index
            break

    # Bail out back to Exploit Suggestion

    # Call LLM to supply ExploitSteps to complete the task
    exploit_planner_prompt_template = get_exploit_planner_prompt_template()
    exploit_planner_prompt = exploit_planner_prompt_template.invoke(
        {
            "exploit_task": exploit_task["task"],
            "target": target,
            "context": ""
        }
    )

    llm_with_tools = llm.bind_tools([ExploitStepFormatter])
    response = llm_invoke_retry(llm_with_tools, exploit_planner_prompt)

    #Update state table
    steps = response.tool_calls[0]["args"]["steps"]
    exploit_steps: [ExploitStepFormatter] = list(map(lambda x: create_exploit_step(x), steps))
    exploit_steps.append(create_exploit_step("Create initial access exploit for the target"))
    exploit_steps.append(create_exploit_step("Verify the initial access exploit by sending the `pwd` command"))

    output_task = deepcopy(state["tasks"][ current_task ])
    output_task["output"][exploit_task_index]["steps"] = exploit_steps
    output_task["output"][exploit_task_index]["status"] = "working"

    return {
        "tasks": output_task
    }

def exploit_step_processor(state: StingerState):
    """
    Finds the ExploitTask current_step and send the step with data
    to the LLM to find a tool.
    """
    input_exploit_task_index:int = get_current_exploit_task(state)
    input_exploit_task:ExploitTask = state["tasks"][ state["current_task"] ]["output"][ input_exploit_task_index ]
    output_task:Task = deepcopy(state["tasks"][ state["current_task"] ])

    exploit_steps:List[ExploitStep] = input_exploit_task["steps"]
    current_step_index:int = get_current_exploit_step(state)

    step_task:str = exploit_steps[current_step_index]["step_task"]
    exploit_step_prompt_template = get_exploit_step_prompt_template()

    context = build_exploit_task_context(state)

    exploit_step_prompt = exploit_step_prompt_template.invoke(
        {
            "agents": sp.agent_prompt_data(),
            "step": step_task,
            "context": context
        }
    )

    llm_with_tools = llm.bind_tools(rb_tools+[SpecialAgentCaller])
    response: AIMessage = llm_invoke_retry(llm_with_tools, exploit_step_prompt)

    scratchpad:str = f"{ response.content }\n{ response.tool_calls }"
    output_task["output"][input_exploit_task_index]["steps"][current_step_index]["status"] = "working"
    output_task["output"][input_exploit_task_index]["steps"][current_step_index]["scratchpad"] = scratchpad

    return {
        "messages": response,
        "tasks": output_task
    }

def exploit_step_tool_router(state:StingerState):
    # Check the last message tool call for the name of the tool
    if state["messages"][-1].tool_calls[0]["name"] == 'SpecialAgentCaller':
        return "ExploitSpecialAgentNode"
    else:
        return "ExploitStepToolNode"

async def exploit_step_special_agent_node(state: StingerState):
    agent_to_call = state["messages"][-1].tool_calls[0]["args"]["name"]
    response = await sp.agents[agent_to_call].graph.ainvoke(state)
    return response

def exploit_step_update(state: StingerState):
    ai_messages:List[AIMessage] = []
    exploit_task_index:int = get_current_exploit_task(state)
    exploit_step_index:int = get_current_exploit_step(state)
    output_task: Task = deepcopy(state["tasks"][state["current_task"]])

    last_message:ToolMessage|AIMessage = state["messages"][-1]
    if last_message.type == 'tool':
        ai_messages.append(AIMessage("ExploitStepUpdate: Appending Tool call output"))
        tool_output:str = last_message.content if isinstance(last_message, AIMessage) else json_loads(last_message.content)["content"]
        # noinspection PyTypeChecker,PyUnresolvedReferences
        output_task["output"][exploit_task_index]["steps"][exploit_step_index]["scratchpad"] += f"\n{tool_output}"
        return {
            "messages": ai_messages,
            "tasks":output_task
        }
    else:
        return {
            "messages": AIMessage("ExploitStepUpdate: No Tool Call output found."),
            "tasks": output_task
        }

def exploit_step_revizor(state: StingerState):
    """
    Check if the exploitstep executed correctly
    If step tool array length is >= MAX_RETRIES then mark as failed and bail
    If validated, setup to move on to next step
    if failed, update step with revision
    """

    ai_messages:List[AIMessage] = []
    current_task:int = state["current_task"]
    input_task:Task = state["tasks"][current_task]
    output_task:Task = deepcopy(state["tasks"][current_task])

    exploit_task_index:int = get_current_exploit_task(state)
    exploit_task:ExploitTask = input_task["output"][exploit_task_index]

    exploit_steps:list[ExploitStep] = exploit_task["steps"]

    current_step:int = get_current_exploit_step(state)
    # noinspection PyTypeChecker
    exploit_step:ExploitStepFormatter = exploit_task["steps"][ current_step]
    ai_messages.append(AIMessage(f"ExploitStepRevizor: Checking status of Exploit Task {exploit_task_index}, step {current_step}."))

    exploit_step_status_template:ChatPromptTemplate = get_exploit_step_status_template()
    exploit_step_status_prompt:PromptValue = exploit_step_status_template.invoke(
        {
            "step": exploit_step,
            "exploit_task": exploit_task
        }
    )

    llm_with_tools:Runnable = llm.bind_tools([ExploitStepUpdates, ExploitTaskUpdates])

    # Retry loop since sometimes the tool call comes back blank
    for i in range(0,3):
        try:
            response:Output =  llm_invoke_retry(llm_with_tools,exploit_step_status_prompt)
            output: AIMessage = response
            if output.tool_calls[0]["name"] == 'ExploitStepUpdates':
                x: [ExploitStep] = response.tool_calls[0]["args"]["updates"]
            elif output.tool_calls[0]["name"] == 'ExploitTaskUpdates':
                x: str = response.tool_calls[0]["args"]["initial_access_exploit"]
            break
        except KeyError as e:
            ai_messages.append(AIMessage(f"ExploitStepRevizor: Failed to get valid response. Error: {e}"))

    ai_messages.append(response)


    # Update the exploit task steps with the new version from the LLM
    # annoying_debug(response)

    if output.tool_calls[0]["name"] == 'ExploitStepUpdates':
        output_steps:[ExploitStep] = response.tool_calls[0]["args"]["updates"]

        original_ids:[str] = [x["id"] for x in exploit_steps]
        output_ids:[str] = [x["id"] for x in output_steps]

        # Check that all steps are accounted for and present
        ai_messages.append(AIMessage("ExploitStepRevizor: Repopulated Exploit Steps scratchpads"))
        if original_ids == output_ids: # ordered 1-1 match
            for i,step in enumerate(exploit_steps):
                output_steps[i]["scratchpad"] = step["scratchpad"]
        else:
            repair_scratchpad(output_steps, exploit_steps)

        output_task["output"][exploit_task_index]["steps"] = output_steps

    elif output.tool_calls[0]["name"] == 'ExploitTaskUpdates':
        new_initial_access_exploit:str = response.tool_calls[0]["args"]["initial_access_exploit"]
        new_status:str = response.tool_calls[0]["args"]["status"]

        output_task["output"][exploit_task_index]["status"] = new_status
        output_task["output"][exploit_task_index]["initial_access_exploit"] = new_initial_access_exploit
        # Manually validate last step
        output_task["output"][exploit_task_index]["steps"][-1]["status"] = "validated"
    return {
        "messages": ai_messages,
        "tasks": output_task
    }


def exploit_step_router(state:StingerState):
    current_working_exploit_task_index:int = get_current_exploit_task(state)

    if current_working_exploit_task_index is None:
        return "ExploitAgent"
    else:
        return "ExploitStepProcessor"

# noinspection PyTypeChecker
exploit_workflow = StateGraph(StingerState)

exploit_workflow.add_edge(START, "LoadPickle")
# noinspection PyTypeChecker
exploit_workflow.add_node("LoadPickle", load_pickle)

exploit_workflow.add_edge("LoadPickle", "ExploitAgent")
# noinspection PyTypeChecker
exploit_workflow.add_node("ExploitAgent", exploit_agent)

exploit_workflow.add_conditional_edges("ExploitAgent", exploit_router, ["ExploitHandoff", "ExploitValidator", "ExploitStepPlanner"])

# noinspection PyTypeChecker
exploit_workflow.add_node("ExploitHandoff", handoff)
# noinspection PyTypeChecker
exploit_workflow.add_node("ExploitValidator", validator)
exploit_workflow.add_edge("ExploitValidator", "ExploitAgent")

###################################
# Nodes for executing exploit steps
###################################
# noinspection PyTypeChecker
exploit_workflow.add_node("ExploitStepPlanner", exploit_step_planner)

exploit_workflow.add_edge("ExploitStepPlanner", "ExploitStepProcessor")
# noinspection PyTypeChecker
exploit_workflow.add_node("ExploitStepProcessor", exploit_step_processor)

exploit_workflow.add_conditional_edges("ExploitStepProcessor", exploit_step_tool_router, ["ExploitStepToolNode", "ExploitSpecialAgentNode"])
exploit_workflow.add_node("ExploitStepToolNode", exploit_step_tool_node)
# noinspection PyTypeChecker
exploit_workflow.add_node("ExploitSpecialAgentNode", exploit_step_special_agent_node)

exploit_workflow.add_edge("ExploitStepToolNode", "ExploitStepUpdate")
exploit_workflow.add_edge("ExploitSpecialAgentNode", "ExploitStepUpdate")
# noinspection PyTypeChecker
exploit_workflow.add_node("ExploitStepUpdate", exploit_step_update)

exploit_workflow.add_edge("ExploitStepUpdate","ExploitStepRevizor")
# noinspection PyTypeChecker
exploit_workflow.add_node("ExploitStepRevizor", exploit_step_revizor)

exploit_workflow.add_conditional_edges("ExploitStepRevizor", exploit_step_router, ["ExploitStepProcessor","ExploitAgent"])


exploit_graph = exploit_workflow.compile()

if __name__ == "__main__":
    # print(os.getcwd())
    # noinspection PyTypeChecker
    exploit_graph.invoke({})